### 集群架构：与网络服务共存

前文已经说明，dispatch server必须以单进程方式运行，才能正常转发消息，这样就导致我们必须单独启动一个beyod serverr实例, 会给部署和运维带来一些麻烦，如果集群规模较小，完全可以让beyod server中同时提供网络服务和dispatcher server, 只需要做简单的操作即可：

#### 1. 配置网络服务和dispatcher server：
config/main.php
```
'components' => [
        'server' => [
            'class' => 'app\MyServer', //使用自定义的类
            'worker_num' => 17, //1个进程提供dispatcher server, 其16个进程提供网络服务
            //配置网络服务
            'listeners' => [
                'http' => [
                    'class' => 'beyod\Listener',
                    'listen' => 'tcp://0.0.0.0:9723',//监听的协议和端口
                    'handler' => [//网络事件回调处理器
                        'class' => 'beyod\protocol\http\Handler',
                        'document_root' => __DIR__.'/../webroot',
                    ],
                    'parser'  => [
                        'class'=>'beyod\protocol\http\Parser',
                    ],
                ],
                
                //订阅服务器
                'dispatch' => [
                    'class' => 'beyod\Listenner',
                    'listen' => 'tcp://0.0.0.0:7724',
                    'parser' => 'beyod\dispatcher\Parser',
                    'handler' => 'beyod\dispatcher\Handler'
                ],
            ],
        ],
        
        //...
]
```

#### 2. 设置进程的功能角色
app\MyServer.php
```
<?php

namespace app;

use Yii;
use beyod\Server;
use beyod\MessageEvent;
use beyod\IOEvent;

class MyServer extends \beyod\Server
{
    public function onWorkerStart($workerId, $GPID)
    {
        parent::onWorkerStart($workerId, $GPID);
        
        //在第一个进程上，停止所有网络服务，只启动dispater server。
        if($workerId ==1) {
            foreach($this->listenners as $name => $listenner) {
                if($name == 'dispatch') continue;
                $listenner->stopAccept();
            }
        }
    }
}
```

如此，我们就可以很容易通过进程id设置其功能，对简化部署和运维，会有不少的帮助。
